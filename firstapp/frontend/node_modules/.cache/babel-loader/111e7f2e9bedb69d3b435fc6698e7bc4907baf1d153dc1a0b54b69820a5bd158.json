{"ast":null,"code":"import { ViewContainer } from '../../view/ViewContainer.mjs';\nimport { particleData } from './particleData.mjs';\n\"use strict\";\nconst emptyBounds = {\n  minX: 0,\n  minY: 0,\n  maxX: 0,\n  maxY: 0\n};\nconst _ParticleContainer = class _ParticleContainer extends ViewContainer {\n  /**\n   * @param options - The options for creating the sprite.\n   */\n  constructor(options = {}) {\n    options = {\n      ..._ParticleContainer.defaultOptions,\n      ...options,\n      dynamicProperties: {\n        ..._ParticleContainer.defaultOptions.dynamicProperties,\n        ...options?.dynamicProperties\n      }\n    };\n    const {\n      dynamicProperties,\n      shader,\n      roundPixels,\n      texture,\n      particles,\n      ...rest\n    } = options;\n    super({\n      label: \"ParticleContainer\",\n      ...rest\n    });\n    /** The unique identifier for the render pipe of this ParticleContainer. */\n    this.renderPipeId = \"particle\";\n    this.batched = false;\n    /** Indicates if the children of this ParticleContainer have changed and need to be updated. */\n    this._childrenDirty = false;\n    this.texture = texture || null;\n    this.shader = shader;\n    this._properties = {};\n    for (const key in particleData) {\n      const property = particleData[key];\n      const dynamic = dynamicProperties[key];\n      this._properties[key] = {\n        ...property,\n        dynamic\n      };\n    }\n    this.allowChildren = true;\n    this.roundPixels = roundPixels ?? false;\n    this.particleChildren = particles ?? [];\n  }\n  /**\n   * Adds one or more particles to the container.\n   *\n   * Multiple items can be added like so: `myContainer.addParticle(thingOne, thingTwo, thingThree)`\n   * @param {...IParticle} children - The Particle(s) to add to the container\n   * @returns {IParticle} - The first child that was added.\n   */\n  addParticle(...children) {\n    for (let i = 0; i < children.length; i++) {\n      this.particleChildren.push(children[i]);\n    }\n    this.onViewUpdate();\n    return children[0];\n  }\n  /**\n   * Removes one or more particles from the container.\n   * @param {...IParticle} children - The Particle(s) to remove\n   * @returns {IParticle} The first child that was removed.\n   */\n  removeParticle(...children) {\n    let didRemove = false;\n    for (let i = 0; i < children.length; i++) {\n      const index = this.particleChildren.indexOf(children[i]);\n      if (index > -1) {\n        this.particleChildren.splice(index, 1);\n        didRemove = true;\n      }\n    }\n    if (didRemove) this.onViewUpdate();\n    return children[0];\n  }\n  /**\n   * Updates the particle container.\n   * Please call this when you modify the particleChildren array.\n   * or any static properties of the particles.\n   */\n  update() {\n    this._childrenDirty = true;\n  }\n  onViewUpdate() {\n    this._childrenDirty = true;\n    super.onViewUpdate();\n  }\n  /**\n   * ParticleContainer does not calculated bounds as it would slow things down,\n   * its up to you to set this via the boundsArea property\n   */\n  get bounds() {\n    return emptyBounds;\n  }\n  /**\n   * ParticleContainer does not calculated bounds as it would slow things down,\n   * its up to you to set this via the boundsArea property\n   * @param _bounds - The output bounds object.\n   */\n  addBounds(_bounds) {}\n  /**\n   * Destroys this sprite renderable and optionally its texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n   */\n  destroy(options = false) {\n    super.destroy(options);\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      const texture = this.texture ?? this.particleChildren[0]?.texture;\n      if (texture) {\n        texture.destroy(destroyTextureSource);\n      }\n    }\n    this.texture = null;\n    this.shader?.destroy();\n  }\n  /**\n   * Removes all particles from this container that are within the begin and end indexes.\n   * @param beginIndex - The beginning position.\n   * @param endIndex - The ending position. Default value is size of the container.\n   * @returns - List of removed particles\n   */\n  removeParticles(beginIndex, endIndex) {\n    const children = this.particleChildren.splice(beginIndex, endIndex);\n    this.onViewUpdate();\n    return children;\n  }\n  /**\n   * Removes a particle from the specified index position.\n   * @param index - The index to get the particle from\n   * @returns The particle that was removed.\n   */\n  removeParticleAt(index) {\n    const child = this.particleChildren.splice(index, 1);\n    this.onViewUpdate();\n    return child[0];\n  }\n  /**\n   * Adds a particle to the container at a specified index. If the index is out of bounds an error will be thrown.\n   * If the particle is already in this container, it will be moved to the specified index.\n   * @param {Container} child - The particle to add.\n   * @param {number} index - The absolute index where the particle will be positioned at the end of the operation.\n   * @returns {Container} The particle that was added.\n   */\n  addParticleAt(child, index) {\n    this.particleChildren.splice(index, 0, child);\n    this.onViewUpdate();\n    return child;\n  }\n  /**\n   * This method is not available in ParticleContainer.\n   *\n   * Calling this method will throw an error. Please use `ParticleContainer.addParticle()` instead.\n   * @param {...any} _children\n   * @throws {Error} Always throws an error as this method is not available.\n   */\n  addChild(..._children) {\n    throw new Error(\"ParticleContainer.addChild() is not available. Please use ParticleContainer.addParticle()\");\n  }\n  /**\n   * This method is not available in ParticleContainer.\n   * Calling this method will throw an error. Please use `ParticleContainer.removeParticle()` instead.\n   * @param {...any} _children\n   * @throws {Error} Always throws an error as this method is not available.\n   */\n  removeChild(..._children) {\n    throw new Error(\"ParticleContainer.removeChild() is not available. Please use ParticleContainer.removeParticle()\");\n  }\n  /**\n   * This method is not available in ParticleContainer.\n   *\n   * Calling this method will throw an error. Please use `ParticleContainer.removeParticles()` instead.\n   * @param {number} [_beginIndex]\n   * @param {number} [_endIndex]\n   * @throws {Error} Always throws an error as this method is not available.\n   */\n  removeChildren(_beginIndex, _endIndex) {\n    throw new Error(\"ParticleContainer.removeChildren() is not available. Please use ParticleContainer.removeParticles()\");\n  }\n  /**\n   * This method is not available in ParticleContainer.\n   *\n   * Calling this method will throw an error. Please use `ParticleContainer.removeParticleAt()` instead.\n   * @param {number} _index\n   * @throws {Error} Always throws an error as this method is not available.\n   */\n  removeChildAt(_index) {\n    throw new Error(\"ParticleContainer.removeChildAt() is not available. Please use ParticleContainer.removeParticleAt()\");\n  }\n  /**\n   * This method is not available in ParticleContainer.\n   *\n   * Calling this method will throw an error. Please use `ParticleContainer.getParticleAt()` instead.\n   * @param {number} _index\n   * @throws {Error} Always throws an error as this method is not available.\n   */\n  getChildAt(_index) {\n    throw new Error(\"ParticleContainer.getChildAt() is not available. Please use ParticleContainer.getParticleAt()\");\n  }\n  /**\n   * This method is not available in ParticleContainer.\n   *\n   * Calling this method will throw an error. Please use `ParticleContainer.setParticleIndex()` instead.\n   * @param {ContainerChild} _child\n   * @param {number} _index\n   * @throws {Error} Always throws an error as this method is not available.\n   */\n  setChildIndex(_child, _index) {\n    throw new Error(\"ParticleContainer.setChildIndex() is not available. Please use ParticleContainer.setParticleIndex()\");\n  }\n  /**\n   * This method is not available in ParticleContainer.\n   *\n   * Calling this method will throw an error. Please use `ParticleContainer.getParticleIndex()` instead.\n   * @param {ContainerChild} _child\n   * @throws {Error} Always throws an error as this method is not available.\n   */\n  getChildIndex(_child) {\n    throw new Error(\"ParticleContainer.getChildIndex() is not available. Please use ParticleContainer.getParticleIndex()\");\n  }\n  /**\n   * This method is not available in ParticleContainer.\n   *\n   * Calling this method will throw an error. Please use `ParticleContainer.addParticleAt()` instead.\n   * @param {ContainerChild} _child\n   * @param {number} _index\n   * @throws {Error} Always throws an error as this method is not available.\n   */\n  addChildAt(_child, _index) {\n    throw new Error(\"ParticleContainer.addChildAt() is not available. Please use ParticleContainer.addParticleAt()\");\n  }\n  /**\n   * This method is not available in ParticleContainer.\n   *\n   * Calling this method will throw an error. Please use `ParticleContainer.swapParticles()` instead.\n   * @param {ContainerChild} _child\n   * @param {ContainerChild} _child2\n   */\n  swapChildren(_child, _child2) {\n    throw new Error(\"ParticleContainer.swapChildren() is not available. Please use ParticleContainer.swapParticles()\");\n  }\n  /**\n   * This method is not available in ParticleContainer.\n   *\n   * Calling this method will throw an error.\n   * @param _child - The child to reparent\n   * @throws {Error} Always throws an error as this method is not available.\n   */\n  reparentChild(..._child) {\n    throw new Error(\"ParticleContainer.reparentChild() is not available with the particle container\");\n  }\n  /**\n   * This method is not available in ParticleContainer.\n   *\n   * Calling this method will throw an error.\n   * @param _child - The child to reparent\n   * @param _index - The index to reparent the child to\n   * @throws {Error} Always throws an error as this method is not available.\n   */\n  reparentChildAt(_child, _index) {\n    throw new Error(\"ParticleContainer.reparentChildAt() is not available with the particle container\");\n  }\n};\n/**\n * Defines the default options for creating a ParticleContainer.\n * @property {Record<string, boolean>} dynamicProperties - Specifies which properties are dynamic.\n * @property {boolean} roundPixels - Indicates if pixels should be  rounded.\n */\n_ParticleContainer.defaultOptions = {\n  dynamicProperties: {\n    vertex: false,\n    // Indicates if vertex positions are dynamic.\n    position: true,\n    // Indicates if particle positions are dynamic.\n    rotation: false,\n    // Indicates if particle rotations are dynamic.\n    uvs: false,\n    // Indicates if UV coordinates are dynamic.\n    color: false\n    // Indicates if particle colors are dynamic.\n  },\n  roundPixels: false\n  // Indicates if pixels should be rounded for rendering.\n};\nlet ParticleContainer = _ParticleContainer;\nexport { ParticleContainer };","map":{"version":3,"names":["emptyBounds","minX","minY","maxX","maxY","_ParticleContainer","ViewContainer","constructor","options","defaultOptions","dynamicProperties","shader","roundPixels","texture","particles","rest","label","renderPipeId","batched","_childrenDirty","_properties","key","particleData","property","dynamic","allowChildren","particleChildren","addParticle","children","i","length","push","onViewUpdate","removeParticle","didRemove","index","indexOf","splice","update","bounds","addBounds","_bounds","destroy","destroyTexture","destroyTextureSource","textureSource","removeParticles","beginIndex","endIndex","removeParticleAt","child","addParticleAt","addChild","_children","Error","removeChild","removeChildren","_beginIndex","_endIndex","removeChildAt","_index","getChildAt","setChildIndex","_child","getChildIndex","addChildAt","swapChildren","_child2","reparentChild","reparentChildAt","vertex","position","rotation","uvs","color","ParticleContainer"],"sources":["/Users/huangjiashu/Desktop/AI Projects/node_modules/pixi.js/src/scene/particle-container/shared/ParticleContainer.ts"],"sourcesContent":["import { ViewContainer } from '../../view/ViewContainer';\nimport { particleData } from './particleData';\n\nimport type { Instruction } from '../../../rendering/renderers/shared/instructions/Instruction';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Bounds, BoundsData } from '../../container/bounds/Bounds';\nimport type { ContainerChild, ContainerOptions } from '../../container/Container';\nimport type { DestroyOptions } from '../../container/destroyTypes';\nimport type { IParticle } from './Particle';\nimport type { ParticleRendererProperty } from './particleData';\n\nconst emptyBounds: BoundsData = {\n    minX: 0,\n    minY: 0,\n    maxX: 0,\n    maxY: 0,\n};\n\n/**\n * Represents the properties of a particle that can be dynamically updated.\n * @property {boolean} [vertices] - Indicates if vertices are dynamic.\n * @property {boolean} [position] - Indicates if position is dynamic.\n * @property {boolean} [rotation] - Indicates if rotation is dynamic.\n * @property {boolean} [uvs] - Indicates if UVs are dynamic.\n * @property {boolean} [color] - Indicates if color is dynamic.\n * @memberof scene\n */\nexport interface ParticleProperties\n{\n    vertex?: boolean;\n    position?: boolean;\n    rotation?: boolean;\n    uvs?: boolean;\n    color?: boolean;\n}\n\n/**\n * Options for the ParticleContainer constructor.\n * @extends ContainerOptions\n * @property {Record<string, boolean>} dynamicProperties - Specifies which properties are dynamic.\n * @property {Shader} shader - The shader to use for rendering.\n * @property {boolean} roundPixels - Indicates if pixels should be rounded.\n * @property {Texture} texture - The texture to use for rendering - if not provided the texture of the first child is used.\n * @property {IParticle[]} particles - An array of particles to add to the container.\n * @memberof scene\n */\nexport interface ParticleContainerOptions extends Omit<ContainerOptions, 'children'>\n{\n    dynamicProperties?: Record<string, boolean>;\n    shader?: Shader;\n    roundPixels?: boolean;\n    texture?: Texture;\n    particles?: IParticle[];\n}\n\n/**\n * The ParticleContainer class is a highly optimized container that can render 1000s or particles at great speed.\n *\n * A ParticleContainer is specialized in that it can only contain and render particles. Particles are\n * lightweight objects that use minimal memory, which helps boost performance.\n *\n * It can render particles EXTREMELY fast!\n *\n * The tradeoff of using a ParticleContainer is that most advanced functionality is unavailable. Particles are simple\n * and cannot have children, filters, masks, etc. They possess only the basic properties: position, scale, rotation,\n * and color.\n *\n * All particles must share the same texture source (using something like a sprite sheet works well here).\n *\n * When creating a ParticleContainer, a developer can specify which of these properties are static and which are dynamic.\n * - Static properties are only updated when you add or remove a child, or when the `update` function is called.\n * - Dynamic properties are updated every frame.\n *\n * It is up to the developer to specify which properties are static and which are dynamic. Generally, the more static\n * properties you have (i.e., those that do not change per frame), the faster the rendering.\n *\n * If the developer modifies the children order or any static properties of the particle, they must call the `update` method.\n *\n * By default, only the `position` property is set to dynamic, which makes rendering very fast!\n *\n * Developers can also provide a custom shader to the particle container, allowing them to render particles in a custom way.\n *\n * To help with performance, the particle containers bounds are not calculated.\n * It's up to the developer to set the boundsArea property.\n *\n * It's extremely easy to use. Below is an example of rendering thousands of sprites at lightning speed.\n *\n * --------- EXPERIMENTAL ---------\n *\n * This is a new API, things may change and it may not work as expected.\n * We want to hear your feedback as we go!\n *\n * --------------------------------\n * @example\n * import { ParticleContainer, Particle } from 'pixi.js';\n *\n * const container = new ParticleContainer();\n *\n * for (let i = 0; i < 100; ++i)\n * {\n *     let particle = new Particle(texture);\n *     container.addParticle(particle);\n * }\n * @memberof scene\n */\nexport class ParticleContainer extends ViewContainer implements Instruction\n{\n    /**\n     * Defines the default options for creating a ParticleContainer.\n     * @property {Record<string, boolean>} dynamicProperties - Specifies which properties are dynamic.\n     * @property {boolean} roundPixels - Indicates if pixels should be  rounded.\n     */\n    public static defaultOptions: ParticleContainerOptions = {\n        dynamicProperties: {\n            vertex: false, // Indicates if vertex positions are dynamic.\n            position: true, // Indicates if particle positions are dynamic.\n            rotation: false, // Indicates if particle rotations are dynamic.\n            uvs: false, // Indicates if UV coordinates are dynamic.\n            color: false, // Indicates if particle colors are dynamic.\n        },\n        roundPixels: false, // Indicates if pixels should be rounded for rendering.\n    };\n\n    /** The unique identifier for the render pipe of this ParticleContainer. */\n    public override readonly renderPipeId: string = 'particle';\n\n    public batched = false;\n\n    /**\n     * A record of properties and their corresponding ParticleRendererProperty.\n     * @internal\n     */\n    public _properties: Record<string, ParticleRendererProperty>;\n\n    /** Indicates if the children of this ParticleContainer have changed and need to be updated. */\n    public _childrenDirty = false;\n\n    /**\n     * An array of particles that are children of this ParticleContainer.\n     * it can be modified directly, after which the 'update' method must be called.\n     * to ensure the container is rendered correctly.\n     */\n    public particleChildren: IParticle[];\n\n    /** The shader used for rendering particles in this ParticleContainer. */\n    public shader: Shader;\n\n    /**\n     * The texture used for rendering particles in this ParticleContainer.\n     * Defaults to the first childs texture if not set\n     */\n    public texture: Texture;\n\n    /**\n     * @param options - The options for creating the sprite.\n     */\n    constructor(options: ParticleContainerOptions = {})\n    {\n        options = {\n            ...ParticleContainer.defaultOptions,\n            ...options,\n            dynamicProperties: {\n                ...ParticleContainer.defaultOptions.dynamicProperties,\n                ...options?.dynamicProperties,\n            },\n        };\n\n        // split out\n        const { dynamicProperties, shader, roundPixels, texture, particles, ...rest } = options;\n\n        super({\n            label: 'ParticleContainer',\n            ...rest,\n        });\n\n        this.texture = texture || null;\n        this.shader = shader;\n\n        this._properties = {};\n\n        for (const key in particleData)\n        {\n            const property = particleData[key];\n            const dynamic = dynamicProperties[key];\n\n            this._properties[key] = {\n                ...property,\n                dynamic,\n            };\n        }\n\n        this.allowChildren = true;\n        this.roundPixels = roundPixels ?? false;\n\n        this.particleChildren = particles ?? [];\n    }\n\n    /**\n     * Adds one or more particles to the container.\n     *\n     * Multiple items can be added like so: `myContainer.addParticle(thingOne, thingTwo, thingThree)`\n     * @param {...IParticle} children - The Particle(s) to add to the container\n     * @returns {IParticle} - The first child that was added.\n     */\n    public addParticle(...children: IParticle[]): IParticle\n    {\n        for (let i = 0; i < children.length; i++)\n        {\n            this.particleChildren.push(children[i]);\n        }\n\n        this.onViewUpdate();\n\n        return children[0];\n    }\n\n    /**\n     * Removes one or more particles from the container.\n     * @param {...IParticle} children - The Particle(s) to remove\n     * @returns {IParticle} The first child that was removed.\n     */\n    public removeParticle(...children: IParticle[]): IParticle\n    {\n        let didRemove = false;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            const index = this.particleChildren.indexOf(children[i] as IParticle);\n\n            if (index > -1)\n            {\n                this.particleChildren.splice(index, 1);\n                didRemove = true;\n            }\n        }\n\n        if (didRemove) this.onViewUpdate();\n\n        return children[0];\n    }\n\n    /**\n     * Updates the particle container.\n     * Please call this when you modify the particleChildren array.\n     * or any static properties of the particles.\n     */\n    public update()\n    {\n        this._childrenDirty = true;\n    }\n\n    protected override onViewUpdate()\n    {\n        this._childrenDirty = true;\n        super.onViewUpdate();\n    }\n\n    /**\n     * ParticleContainer does not calculated bounds as it would slow things down,\n     * its up to you to set this via the boundsArea property\n     */\n    public get bounds(): BoundsData\n    {\n        return emptyBounds;\n    }\n\n    /**\n     * ParticleContainer does not calculated bounds as it would slow things down,\n     * its up to you to set this via the boundsArea property\n     * @param _bounds - The output bounds object.\n     */\n    public addBounds(_bounds: Bounds): void\n    {\n        // empty\n    }\n\n    /**\n     * Destroys this sprite renderable and optionally its texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n     */\n    public override destroy(options: DestroyOptions = false)\n    {\n        super.destroy(options);\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            const texture = this.texture ?? this.particleChildren[0]?.texture;\n\n            if (texture)\n            {\n                texture.destroy(destroyTextureSource);\n            }\n        }\n\n        this.texture = null;\n        this.shader?.destroy();\n    }\n\n    /**\n     * Removes all particles from this container that are within the begin and end indexes.\n     * @param beginIndex - The beginning position.\n     * @param endIndex - The ending position. Default value is size of the container.\n     * @returns - List of removed particles\n     */\n    public removeParticles(beginIndex?: number, endIndex?: number)\n    {\n        const children = this.particleChildren.splice(beginIndex, endIndex);\n\n        this.onViewUpdate();\n\n        return children;\n    }\n\n    /**\n     * Removes a particle from the specified index position.\n     * @param index - The index to get the particle from\n     * @returns The particle that was removed.\n     */\n    public removeParticleAt<U extends IParticle>(index: number): U\n    {\n        const child = this.particleChildren.splice(index, 1);\n\n        this.onViewUpdate();\n\n        return child[0] as U;\n    }\n\n    /**\n     * Adds a particle to the container at a specified index. If the index is out of bounds an error will be thrown.\n     * If the particle is already in this container, it will be moved to the specified index.\n     * @param {Container} child - The particle to add.\n     * @param {number} index - The absolute index where the particle will be positioned at the end of the operation.\n     * @returns {Container} The particle that was added.\n     */\n    public addParticleAt<U extends IParticle>(child: U, index: number): U\n    {\n        this.particleChildren.splice(index, 0, child);\n\n        this.onViewUpdate();\n\n        return child;\n    }\n\n    /**\n     * This method is not available in ParticleContainer.\n     *\n     * Calling this method will throw an error. Please use `ParticleContainer.addParticle()` instead.\n     * @param {...any} _children\n     * @throws {Error} Always throws an error as this method is not available.\n     */\n    public override addChild<U extends ContainerChild[]>(..._children: U): U[0]\n    {\n        throw new Error(\n            'ParticleContainer.addChild() is not available. Please use ParticleContainer.addParticle()',\n        );\n    }\n    /**\n     * This method is not available in ParticleContainer.\n     * Calling this method will throw an error. Please use `ParticleContainer.removeParticle()` instead.\n     * @param {...any} _children\n     * @throws {Error} Always throws an error as this method is not available.\n     */\n    public override removeChild<U extends ContainerChild[]>(..._children: U): U[0]\n    {\n        throw new Error(\n            'ParticleContainer.removeChild() is not available. Please use ParticleContainer.removeParticle()',\n        );\n    }\n    /**\n     * This method is not available in ParticleContainer.\n     *\n     * Calling this method will throw an error. Please use `ParticleContainer.removeParticles()` instead.\n     * @param {number} [_beginIndex]\n     * @param {number} [_endIndex]\n     * @throws {Error} Always throws an error as this method is not available.\n     */\n    public override removeChildren(_beginIndex?: number, _endIndex?: number): ContainerChild[]\n    {\n        throw new Error(\n            'ParticleContainer.removeChildren() is not available. Please use ParticleContainer.removeParticles()',\n        );\n    }\n    /**\n     * This method is not available in ParticleContainer.\n     *\n     * Calling this method will throw an error. Please use `ParticleContainer.removeParticleAt()` instead.\n     * @param {number} _index\n     * @throws {Error} Always throws an error as this method is not available.\n     */\n    public override removeChildAt<U extends ContainerChild>(_index: number): U\n    {\n        throw new Error(\n            'ParticleContainer.removeChildAt() is not available. Please use ParticleContainer.removeParticleAt()',\n        );\n    }\n    /**\n     * This method is not available in ParticleContainer.\n     *\n     * Calling this method will throw an error. Please use `ParticleContainer.getParticleAt()` instead.\n     * @param {number} _index\n     * @throws {Error} Always throws an error as this method is not available.\n     */\n    public override getChildAt<U extends ContainerChild>(_index: number): U\n    {\n        throw new Error(\n            'ParticleContainer.getChildAt() is not available. Please use ParticleContainer.getParticleAt()',\n        );\n    }\n    /**\n     * This method is not available in ParticleContainer.\n     *\n     * Calling this method will throw an error. Please use `ParticleContainer.setParticleIndex()` instead.\n     * @param {ContainerChild} _child\n     * @param {number} _index\n     * @throws {Error} Always throws an error as this method is not available.\n     */\n    public override setChildIndex(_child: ContainerChild, _index: number): void\n    {\n        throw new Error(\n            'ParticleContainer.setChildIndex() is not available. Please use ParticleContainer.setParticleIndex()',\n        );\n    }\n    /**\n     * This method is not available in ParticleContainer.\n     *\n     * Calling this method will throw an error. Please use `ParticleContainer.getParticleIndex()` instead.\n     * @param {ContainerChild} _child\n     * @throws {Error} Always throws an error as this method is not available.\n     */\n    public override getChildIndex(_child: ContainerChild): number\n    {\n        throw new Error(\n            'ParticleContainer.getChildIndex() is not available. Please use ParticleContainer.getParticleIndex()',\n        );\n    }\n    /**\n     * This method is not available in ParticleContainer.\n     *\n     * Calling this method will throw an error. Please use `ParticleContainer.addParticleAt()` instead.\n     * @param {ContainerChild} _child\n     * @param {number} _index\n     * @throws {Error} Always throws an error as this method is not available.\n     */\n    public override addChildAt<U extends ContainerChild>(_child: U, _index: number): U\n    {\n        throw new Error(\n            'ParticleContainer.addChildAt() is not available. Please use ParticleContainer.addParticleAt()',\n        );\n    }\n    /**\n     * This method is not available in ParticleContainer.\n     *\n     * Calling this method will throw an error. Please use `ParticleContainer.swapParticles()` instead.\n     * @param {ContainerChild} _child\n     * @param {ContainerChild} _child2\n     */\n    public override swapChildren<U extends ContainerChild>(_child: U, _child2: U): void\n    {\n        throw new Error(\n            'ParticleContainer.swapChildren() is not available. Please use ParticleContainer.swapParticles()',\n        );\n    }\n\n    /**\n     * This method is not available in ParticleContainer.\n     *\n     * Calling this method will throw an error.\n     * @param _child - The child to reparent\n     * @throws {Error} Always throws an error as this method is not available.\n     */\n    public override reparentChild(..._child: ContainerChild[]): any\n    {\n        throw new Error('ParticleContainer.reparentChild() is not available with the particle container');\n    }\n\n    /**\n     * This method is not available in ParticleContainer.\n     *\n     * Calling this method will throw an error.\n     * @param _child - The child to reparent\n     * @param _index - The index to reparent the child to\n     * @throws {Error} Always throws an error as this method is not available.\n     */\n    public override reparentChildAt(_child: ContainerChild, _index: number): any\n    {\n        throw new Error('ParticleContainer.reparentChildAt() is not available with the particle container');\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}