{"ast":null,"code":"import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { collectAllRenderables } from '../../../scene/container/utils/buildInstructions.mjs';\nimport { CLEAR } from '../../renderers/gl/const.mjs';\nimport { STENCIL_MODES } from '../../renderers/shared/state/const.mjs';\n\"use strict\";\nclass StencilMaskPipe {\n  constructor(renderer) {\n    // used when building and also when executing..\n    this._maskStackHash = {};\n    this._maskHash = /* @__PURE__ */new WeakMap();\n    this._renderer = renderer;\n  }\n  push(mask, _container, instructionSet) {\n    var _a;\n    const effect = mask;\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    renderer.renderPipes.blendMode.setBlendMode(effect.mask, \"none\", instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"pushMaskBegin\",\n      mask,\n      inverse: _container._maskOptions.inverse,\n      canBundle: false\n    });\n    const maskContainer = effect.mask;\n    maskContainer.includeInBuild = true;\n    if (!this._maskHash.has(effect)) {\n      this._maskHash.set(effect, {\n        instructionsStart: 0,\n        instructionsLength: 0\n      });\n    }\n    const maskData = this._maskHash.get(effect);\n    maskData.instructionsStart = instructionSet.instructionSize;\n    collectAllRenderables(maskContainer, instructionSet, renderer);\n    maskContainer.includeInBuild = false;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"pushMaskEnd\",\n      mask,\n      inverse: _container._maskOptions.inverse,\n      canBundle: false\n    });\n    const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;\n    maskData.instructionsLength = instructionsLength;\n    const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n    (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);\n  }\n  pop(mask, _container, instructionSet) {\n    const effect = mask;\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    renderer.renderPipes.blendMode.setBlendMode(effect.mask, \"none\", instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"popMaskBegin\",\n      inverse: _container._maskOptions.inverse,\n      canBundle: false\n    });\n    const maskData = this._maskHash.get(mask);\n    for (let i = 0; i < maskData.instructionsLength; i++) {\n      instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];\n    }\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"popMaskEnd\",\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    var _a;\n    const renderer = this._renderer;\n    const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n    let maskStackIndex = (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);\n    if (instruction.action === \"pushMaskBegin\") {\n      renderer.renderTarget.ensureDepthStencil();\n      renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);\n      maskStackIndex++;\n      renderer.colorMask.setMask(0);\n    } else if (instruction.action === \"pushMaskEnd\") {\n      if (instruction.inverse) {\n        renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n      } else {\n        renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n      }\n      renderer.colorMask.setMask(15);\n    } else if (instruction.action === \"popMaskBegin\") {\n      renderer.colorMask.setMask(0);\n      if (maskStackIndex !== 0) {\n        renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);\n      } else {\n        renderer.renderTarget.clear(null, CLEAR.STENCIL);\n        renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);\n      }\n      maskStackIndex--;\n    } else if (instruction.action === \"popMaskEnd\") {\n      if (instruction.inverse) {\n        renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n      } else {\n        renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n      }\n      renderer.colorMask.setMask(15);\n    }\n    this._maskStackHash[renderTargetUid] = maskStackIndex;\n  }\n  destroy() {\n    this._renderer = null;\n    this._maskStackHash = null;\n    this._maskHash = null;\n  }\n}\nStencilMaskPipe.extension = {\n  type: [ExtensionType.WebGLPipes, ExtensionType.WebGPUPipes, ExtensionType.CanvasPipes],\n  name: \"stencilMask\"\n};\nexport { StencilMaskPipe };","map":{"version":3,"names":["StencilMaskPipe","constructor","renderer","_maskStackHash","_maskHash","WeakMap","_renderer","push","mask","_container","instructionSet","_a","effect","renderPipes","batch","break","blendMode","setBlendMode","add","renderPipeId","action","inverse","_maskOptions","canBundle","maskContainer","includeInBuild","has","set","instructionsStart","instructionsLength","maskData","get","instructionSize","collectAllRenderables","renderTargetUid","renderTarget","uid","pop","i","instructions","execute","instruction","maskStackIndex","ensureDepthStencil","stencil","setStencilMode","STENCIL_MODES","RENDERING_MASK_ADD","colorMask","setMask","INVERSE_MASK_ACTIVE","MASK_ACTIVE","RENDERING_MASK_REMOVE","clear","CLEAR","STENCIL","DISABLED","destroy","extension","type","ExtensionType","WebGLPipes","WebGPUPipes","CanvasPipes","name"],"sources":["/Users/huangjiashu/Desktop/AI Projects/node_modules/pixi.js/src/rendering/mask/stencil/StencilMaskPipe.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { collectAllRenderables } from '../../../scene/container/utils/buildInstructions';\nimport { CLEAR } from '../../renderers/gl/const';\nimport { STENCIL_MODES } from '../../renderers/shared/state/const';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../renderers/shared/Renderable';\nimport type { Renderer } from '../../renderers/types';\nimport type { StencilMask } from './StencilMask';\n\ntype MaskMode = 'pushMaskBegin' | 'pushMaskEnd' | 'popMaskBegin' | 'popMaskEnd';\n\nexport interface StencilMaskInstruction extends Instruction\n{\n    renderPipeId: 'stencilMask',\n    action: MaskMode,\n    inverse: boolean,\n    mask: StencilMask,\n}\n\nexport class StencilMaskPipe implements InstructionPipe<StencilMaskInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'stencilMask',\n    } as const;\n\n    private _renderer: Renderer;\n\n    // used when building and also when executing..\n    private _maskStackHash: Record<number, number> = {};\n\n    private _maskHash = new WeakMap<StencilMask, {\n        instructionsStart: number,\n        instructionsLength: number,\n    }>();\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const effect = mask as StencilMask;\n\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        renderer.renderPipes.blendMode.setBlendMode(effect.mask as Renderable, 'none', instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'pushMaskBegin',\n            mask,\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const maskContainer = effect.mask;\n\n        maskContainer.includeInBuild = true;\n\n        if (!this._maskHash.has(effect))\n        {\n            this._maskHash.set(effect, {\n                instructionsStart: 0,\n                instructionsLength: 0,\n            });\n        }\n\n        const maskData = this._maskHash.get(effect);\n\n        maskData.instructionsStart = instructionSet.instructionSize;\n\n        collectAllRenderables(\n            maskContainer,\n            instructionSet,\n            renderer,\n        );\n\n        maskContainer.includeInBuild = false;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'pushMaskEnd',\n            mask,\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;\n\n        maskData.instructionsLength = instructionsLength;\n\n        const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n\n        this._maskStackHash[renderTargetUid] ??= 0;\n    }\n\n    public pop(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const effect = mask as StencilMask;\n\n        const renderer = this._renderer;\n\n        // stencil is stored based on current render target..\n        renderer.renderPipes.batch.break(instructionSet);\n        renderer.renderPipes.blendMode.setBlendMode(effect.mask as Renderable, 'none', instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'popMaskBegin',\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const maskData = this._maskHash.get(mask as StencilMask);\n\n        for (let i = 0; i < maskData.instructionsLength; i++)\n        {\n            // eslint-disable-next-line max-len\n            instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];\n        }\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'popMaskEnd',\n            canBundle: false,\n        });\n    }\n\n    public execute(instruction: StencilMaskInstruction)\n    {\n        const renderer = this._renderer;\n        const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n\n        let maskStackIndex = this._maskStackHash[renderTargetUid] ??= 0;\n\n        if (instruction.action === 'pushMaskBegin')\n        {\n            // we create the depth and stencil buffers JIT\n            // as no point allocating the memory if we don't use it\n            renderer.renderTarget.ensureDepthStencil();\n\n            renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);\n\n            maskStackIndex++;\n\n            renderer.colorMask.setMask(0);\n        }\n        else if (instruction.action === 'pushMaskEnd')\n        {\n            if (instruction.inverse)\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n            }\n            else\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n            }\n\n            renderer.colorMask.setMask(0xF);\n        }\n        else if (instruction.action === 'popMaskBegin')\n        {\n            renderer.colorMask.setMask(0);\n\n            if (maskStackIndex !== 0)\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);\n            }\n            else\n            {\n                renderer.renderTarget.clear(null, CLEAR.STENCIL);\n                renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);\n            }\n\n            maskStackIndex--;\n        }\n        else if (instruction.action === 'popMaskEnd')\n        {\n            if (instruction.inverse)\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n            }\n            else\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n            }\n\n            renderer.colorMask.setMask(0xF);\n        }\n\n        this._maskStackHash[renderTargetUid] = maskStackIndex;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n        this._maskStackHash = null;\n        this._maskHash = null;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}