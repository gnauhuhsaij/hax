{"ast":null,"code":"import { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { GlProgram } from '../../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { UniformGroup } from '../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { TextureMatrix } from '../../rendering/renderers/shared/texture/TextureMatrix.mjs';\nimport { Filter } from '../Filter.mjs';\nimport fragment from './mask.frag.mjs';\nimport vertex from './mask.vert.mjs';\nimport source from './mask.wgsl.mjs';\n\"use strict\";\nclass MaskFilter extends Filter {\n  constructor(options) {\n    const {\n      sprite,\n      ...rest\n    } = options;\n    const textureMatrix = new TextureMatrix(sprite.texture);\n    const filterUniforms = new UniformGroup({\n      uFilterMatrix: {\n        value: new Matrix(),\n        type: \"mat3x3<f32>\"\n      },\n      uMaskClamp: {\n        value: textureMatrix.uClampFrame,\n        type: \"vec4<f32>\"\n      },\n      uAlpha: {\n        value: 1,\n        type: \"f32\"\n      },\n      uInverse: {\n        value: options.inverse ? 1 : 0,\n        type: \"f32\"\n      }\n    });\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"mask-filter\"\n    });\n    super({\n      ...rest,\n      gpuProgram,\n      glProgram,\n      resources: {\n        filterUniforms,\n        uMaskTexture: sprite.texture.source\n      }\n    });\n    this.sprite = sprite;\n    this._textureMatrix = textureMatrix;\n  }\n  set inverse(value) {\n    this.resources.filterUniforms.uniforms.uInverse = value ? 1 : 0;\n  }\n  get inverse() {\n    return this.resources.filterUniforms.uniforms.uInverse === 1;\n  }\n  apply(filterManager, input, output, clearMode) {\n    this._textureMatrix.texture = this.sprite.texture;\n    filterManager.calculateSpriteMatrix(this.resources.filterUniforms.uniforms.uFilterMatrix, this.sprite).prepend(this._textureMatrix.mapCoord);\n    this.resources.uMaskTexture = this.sprite.texture.source;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n}\nexport { MaskFilter };","map":{"version":3,"names":["MaskFilter","Filter","constructor","options","sprite","rest","textureMatrix","TextureMatrix","texture","filterUniforms","UniformGroup","uFilterMatrix","value","Matrix","type","uMaskClamp","uClampFrame","uAlpha","uInverse","inverse","gpuProgram","GpuProgram","from","vertex","source","entryPoint","fragment","glProgram","GlProgram","name","resources","uMaskTexture","_textureMatrix","uniforms","apply","filterManager","input","output","clearMode","calculateSpriteMatrix","prepend","mapCoord","applyFilter"],"sources":["/Users/huangjiashu/Desktop/AI Projects/node_modules/pixi.js/src/filters/mask/MaskFilter.ts"],"sourcesContent":["import { Matrix } from '../../maths/matrix/Matrix';\nimport { GlProgram } from '../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../rendering/renderers/gpu/shader/GpuProgram';\nimport { UniformGroup } from '../../rendering/renderers/shared/shader/UniformGroup';\nimport { TextureMatrix } from '../../rendering/renderers/shared/texture/TextureMatrix';\nimport { Filter } from '../Filter';\nimport fragment from './mask.frag';\nimport vertex from './mask.vert';\nimport source from './mask.wgsl';\n\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { Sprite } from '../../scene/sprite/Sprite';\nimport type { FilterOptions } from '../Filter';\nimport type { FilterSystem } from '../FilterSystem';\n\nexport interface MaskFilterOptions extends FilterOptions\n{\n    sprite: Sprite,\n    inverse?: boolean;\n    scale?: number | { x: number, y: number },\n}\n\nexport class MaskFilter extends Filter\n{\n    public sprite: Sprite;\n    private readonly _textureMatrix: TextureMatrix;\n\n    constructor(options: MaskFilterOptions)\n    {\n        const { sprite, ...rest } = options;\n\n        const textureMatrix = new TextureMatrix(sprite.texture);\n\n        const filterUniforms = new UniformGroup({\n            uFilterMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uMaskClamp: { value: textureMatrix.uClampFrame, type: 'vec4<f32>' },\n            uAlpha: { value: 1, type: 'f32' },\n            uInverse: { value: options.inverse ? 1 : 0, type: 'f32' },\n        });\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'mask-filter',\n        });\n\n        super({\n            ...rest,\n            gpuProgram,\n            glProgram,\n            resources: {\n                filterUniforms,\n                uMaskTexture: sprite.texture.source,\n            },\n        });\n\n        this.sprite = sprite;\n\n        this._textureMatrix = textureMatrix;\n    }\n\n    set inverse(value: boolean)\n    {\n        this.resources.filterUniforms.uniforms.uInverse = value ? 1 : 0;\n    }\n\n    get inverse(): boolean\n    {\n        return this.resources.filterUniforms.uniforms.uInverse === 1;\n    }\n\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: Texture,\n        clearMode: boolean\n    ): void\n    {\n        // will trigger an update if the texture changed..\n        this._textureMatrix.texture = this.sprite.texture;\n\n        filterManager.calculateSpriteMatrix(\n            this.resources.filterUniforms.uniforms.uFilterMatrix as Matrix,\n            this.sprite\n        ).prepend(this._textureMatrix.mapCoord);\n\n        this.resources.uMaskTexture = this.sprite.texture.source;\n\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n}\n"],"mappings":";;;;;;;;;;AAsBO,MAAMA,UAAA,SAAmBC,MAChC;EAIIC,YAAYC,OACZ;IACI,MAAM;MAAEC,MAAA;MAAQ,GAAGC;IAAA,CAAS,GAAAF,OAAA;IAE5B,MAAMG,aAAgB,OAAIC,aAAc,CAAAH,MAAA,CAAOI,OAAO;IAEhD,MAAAC,cAAA,GAAiB,IAAIC,YAAa;MACpCC,aAAA,EAAe;QAAEC,KAAA,EAAO,IAAIC,MAAO;QAAGC,IAAA,EAAM;MAAc;MAC1DC,UAAA,EAAY;QAAEH,KAAA,EAAON,aAAc,CAAAU,WAAA;QAAaF,IAAA,EAAM;MAAY;MAClEG,MAAQ;QAAEL,KAAO;QAAGE,IAAA,EAAM;MAAM;MAChCI,QAAA,EAAU;QAAEN,KAAO,EAAAT,OAAA,CAAQgB,OAAA,GAAU,CAAI;QAAGL,IAAA,EAAM;MAAM;IAAA,CAC3D;IAEK,MAAAM,UAAA,GAAaC,UAAA,CAAWC,IAAK;MAC/BC,MAAQ;QACJC,MAAA;QACAC,UAAY;MAAA,CAChB;MACAC,QAAU;QACNF,MAAA;QACAC,UAAY;MAAA;IAChB,CACH;IAEK,MAAAE,SAAA,GAAYC,SAAA,CAAUN,IAAK;MAC7BC,MAAA;MACAG,QAAA;MACAG,IAAM;IAAA,CACT;IAEK;MACF,GAAGxB,IAAA;MACHe,UAAA;MACAO,SAAA;MACAG,SAAW;QACPrB,cAAA;QACAsB,YAAA,EAAc3B,MAAA,CAAOI,OAAQ,CAAAgB;MAAA;IACjC,CACH;IAED,KAAKpB,MAAS,GAAAA,MAAA;IAEd,KAAK4B,cAAiB,GAAA1B,aAAA;EAAA;EAG1B,IAAIa,QAAQP,KACZ;IACI,KAAKkB,SAAU,CAAArB,cAAA,CAAewB,QAAS,CAAAf,QAAA,GAAWN,KAAA,GAAQ,CAAI;EAAA;EAGlE,IAAIO,OACJA,CAAA;IACI,OAAO,IAAK,CAAAW,SAAA,CAAUrB,cAAe,CAAAwB,QAAA,CAASf,QAAa;EAAA;EAGxDgB,KACHA,CAAAC,aAAA,EACAC,KACA,EAAAC,MAAA,EACAC,SAEJ;IAES,KAAAN,cAAA,CAAexB,OAAU,QAAKJ,MAAO,CAAAI,OAAA;IAE5B2B,aAAA,CAAAI,qBAAA,CACV,KAAKT,SAAU,CAAArB,cAAA,CAAewB,QAAS,CAAAtB,aAAA,EACvC,IAAK,CAAAP,MAAA,CACP,CAAAoC,OAAA,CAAQ,IAAK,CAAAR,cAAA,CAAeS,QAAQ;IAEtC,KAAKX,SAAU,CAAAC,YAAA,GAAe,IAAK,CAAA3B,MAAA,CAAOI,OAAQ,CAAAgB,MAAA;IAElDW,aAAA,CAAcO,WAAY,OAAMN,KAAO,EAAAC,MAAA,EAAQC,SAAS;EAAA;AAEhE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}