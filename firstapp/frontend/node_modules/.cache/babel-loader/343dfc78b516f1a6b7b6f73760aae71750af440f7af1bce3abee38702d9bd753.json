{"ast":null,"code":"import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer.mjs';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const.mjs';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry.mjs';\nimport { getAttributeInfoFromFormat } from '../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer.mjs';\nimport { createIndicesForQuads } from './utils/createIndicesForQuads.mjs';\nimport { generateParticleUpdateFunction } from './utils/generateParticleUpdateFunction.mjs';\n\"use strict\";\nclass ParticleBuffer {\n  constructor(options) {\n    this._size = 0;\n    this._generateParticleUpdateCache = {};\n    const size = this._size = options.size ?? 1e3;\n    const properties = options.properties;\n    let staticVertexSize = 0;\n    let dynamicVertexSize = 0;\n    for (const i in properties) {\n      const property = properties[i];\n      const attributeInfo = getAttributeInfoFromFormat(property.format);\n      if (property.dynamic) {\n        dynamicVertexSize += attributeInfo.stride;\n      } else {\n        staticVertexSize += attributeInfo.stride;\n      }\n    }\n    this._dynamicStride = dynamicVertexSize / 4;\n    this._staticStride = staticVertexSize / 4;\n    this.staticAttributeBuffer = new ViewableBuffer(size * 4 * staticVertexSize);\n    this.dynamicAttributeBuffer = new ViewableBuffer(size * 4 * dynamicVertexSize);\n    this.indexBuffer = createIndicesForQuads(size);\n    const geometry = new Geometry();\n    let dynamicOffset = 0;\n    let staticOffset = 0;\n    this._staticBuffer = new Buffer({\n      data: new Float32Array(1),\n      label: \"static-particle-buffer\",\n      shrinkToFit: false,\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n    });\n    this._dynamicBuffer = new Buffer({\n      data: new Float32Array(1),\n      label: \"dynamic-particle-buffer\",\n      shrinkToFit: false,\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n    });\n    for (const i in properties) {\n      const property = properties[i];\n      const attributeInfo = getAttributeInfoFromFormat(property.format);\n      if (property.dynamic) {\n        geometry.addAttribute(property.attributeName, {\n          buffer: this._dynamicBuffer,\n          stride: this._dynamicStride * 4,\n          offset: dynamicOffset * 4,\n          format: property.format\n        });\n        dynamicOffset += attributeInfo.size;\n      } else {\n        geometry.addAttribute(property.attributeName, {\n          buffer: this._staticBuffer,\n          stride: this._staticStride * 4,\n          offset: staticOffset * 4,\n          format: property.format\n        });\n        staticOffset += attributeInfo.size;\n      }\n    }\n    geometry.addIndex(this.indexBuffer);\n    const uploadFunction = this.getParticleUpdate(properties);\n    this._dynamicUpload = uploadFunction.dynamicUpdate;\n    this._staticUpload = uploadFunction.staticUpdate;\n    this.geometry = geometry;\n  }\n  getParticleUpdate(properties) {\n    const key = getParticleSyncKey(properties);\n    if (this._generateParticleUpdateCache[key]) {\n      return this._generateParticleUpdateCache[key];\n    }\n    this._generateParticleUpdateCache[key] = this.generateParticleUpdate(properties);\n    return this._generateParticleUpdateCache[key];\n  }\n  generateParticleUpdate(properties) {\n    return generateParticleUpdateFunction(properties);\n  }\n  update(particles, uploadStatic) {\n    if (particles.length > this._size) {\n      uploadStatic = true;\n      this._size = Math.max(particles.length, this._size * 1.5 | 0);\n      this.staticAttributeBuffer = new ViewableBuffer(this._size * this._staticStride * 4 * 4);\n      this.dynamicAttributeBuffer = new ViewableBuffer(this._size * this._dynamicStride * 4 * 4);\n      this.indexBuffer = createIndicesForQuads(this._size);\n      this.geometry.indexBuffer.setDataWithSize(this.indexBuffer, this.indexBuffer.byteLength, true);\n    }\n    const dynamicAttributeBuffer = this.dynamicAttributeBuffer;\n    this._dynamicUpload(particles, dynamicAttributeBuffer.float32View, dynamicAttributeBuffer.uint32View);\n    this._dynamicBuffer.setDataWithSize(this.dynamicAttributeBuffer.float32View, particles.length * this._dynamicStride * 4, true);\n    if (uploadStatic) {\n      const staticAttributeBuffer = this.staticAttributeBuffer;\n      this._staticUpload(particles, staticAttributeBuffer.float32View, staticAttributeBuffer.uint32View);\n      this._staticBuffer.setDataWithSize(staticAttributeBuffer.float32View, particles.length * this._staticStride * 4, true);\n    }\n  }\n  destroy() {\n    this._staticBuffer.destroy();\n    this._dynamicBuffer.destroy();\n    this.geometry.destroy();\n  }\n}\nfunction getParticleSyncKey(properties) {\n  const keyGen = [];\n  for (const key in properties) {\n    const property = properties[key];\n    keyGen.push(key, property.code, property.dynamic ? \"d\" : \"s\");\n  }\n  return keyGen.join(\"_\");\n}\nexport { ParticleBuffer };","map":{"version":3,"names":["ParticleBuffer","constructor","options","_size","_generateParticleUpdateCache","size","properties","staticVertexSize","dynamicVertexSize","i","property","attributeInfo","getAttributeInfoFromFormat","format","dynamic","stride","_dynamicStride","_staticStride","staticAttributeBuffer","ViewableBuffer","dynamicAttributeBuffer","indexBuffer","createIndicesForQuads","geometry","Geometry","dynamicOffset","staticOffset","_staticBuffer","Buffer","data","Float32Array","label","shrinkToFit","usage","BufferUsage","VERTEX","COPY_DST","_dynamicBuffer","addAttribute","attributeName","buffer","offset","addIndex","uploadFunction","getParticleUpdate","_dynamicUpload","dynamicUpdate","_staticUpload","staticUpdate","key","getParticleSyncKey","generateParticleUpdate","generateParticleUpdateFunction","update","particles","uploadStatic","length","Math","max","setDataWithSize","byteLength","float32View","uint32View","destroy","keyGen","push","code","join"],"sources":["/Users/huangjiashu/Desktop/AI Projects/node_modules/pixi.js/src/scene/particle-container/shared/ParticleBuffer.ts"],"sourcesContent":["import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { getAttributeInfoFromFormat } from '../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer';\nimport { createIndicesForQuads } from './utils/createIndicesForQuads';\nimport { generateParticleUpdateFunction } from './utils/generateParticleUpdateFunction';\n\nimport type { IndexBufferArray } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport type { IParticle } from './Particle';\nimport type { ParticleRendererProperty } from './particleData';\nimport type { ParticleUpdateFunction } from './utils/generateParticleUpdateFunction';\n\n/**\n * Options for creating a ParticleBuffer.\n * @property {number} size - The size of the particle buffer.\n * @property {Record<string, ParticleRendererProperty>} properties - A record of attributes that the particle container uses.\n */\nexport interface ParticleBufferOptions\n{\n    size: number;\n    properties: Record<string, ParticleRendererProperty>;\n}\n\n/**\n * The ParticleBuffer holds the buffers and geometry for a particle container.\n * It also contains the upload functions for the static and dynamic properties.\n * @internal\n */\nexport class ParticleBuffer\n{\n    /** The buffer containing static attribute data for all elements in the batch. */\n    public staticAttributeBuffer: ViewableBuffer;\n    /** The buffer containing dynamic attribute data for all elements in the batch. */\n    public dynamicAttributeBuffer: ViewableBuffer;\n\n    private readonly _staticBuffer: Buffer;\n    private readonly _dynamicBuffer: Buffer;\n\n    /** The buffer containing index data for all elements in the batch. */\n    public indexBuffer: IndexBufferArray;\n\n    private readonly _dynamicStride: number;\n    private readonly _staticStride: number;\n\n    /** The geometry of the particle buffer. */\n    public readonly geometry: Geometry;\n\n    private _size = 0;\n    private readonly _dynamicUpload: ParticleUpdateFunction;\n    private readonly _staticUpload: ParticleUpdateFunction;\n    private readonly _generateParticleUpdateCache: Record<string, {\n        dynamicUpdate: ParticleUpdateFunction;\n        staticUpdate: ParticleUpdateFunction;\n    }> = {};\n\n    constructor(options: ParticleBufferOptions)\n    {\n        // size in sprites!\n        const size = this._size = options.size ?? 1000;\n\n        // TODO add the option to specify what is dynamic!\n        const properties = options.properties;\n\n        // in bytes!\n        let staticVertexSize = 0;\n        let dynamicVertexSize = 0;\n\n        for (const i in properties)\n        {\n            const property = properties[i];\n            const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n            if (property.dynamic)\n            {\n                // dynamic.\n                dynamicVertexSize += attributeInfo.stride;\n            }\n            else\n            {\n                // static.\n                staticVertexSize += attributeInfo.stride;\n            }\n        }\n\n        this._dynamicStride = dynamicVertexSize / 4;\n        this._staticStride = staticVertexSize / 4;\n\n        this.staticAttributeBuffer = new ViewableBuffer(size * 4 * staticVertexSize);\n        this.dynamicAttributeBuffer = new ViewableBuffer(size * 4 * dynamicVertexSize);\n\n        this.indexBuffer = createIndicesForQuads(size);\n\n        // build geometry..\n\n        const geometry = new Geometry();\n\n        let dynamicOffset = 0;\n        let staticOffset = 0;\n\n        this._staticBuffer = new Buffer({\n            data: new Float32Array(1),\n            label: 'static-particle-buffer',\n            shrinkToFit: false,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n        });\n\n        this._dynamicBuffer = new Buffer({\n            data: new Float32Array(1),\n            label: 'dynamic-particle-buffer',\n            shrinkToFit: false,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n        });\n\n        for (const i in properties)\n        {\n            const property = properties[i];\n            const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n            if (property.dynamic)\n            {\n                geometry.addAttribute(property.attributeName, {\n                    buffer: this._dynamicBuffer,\n                    stride: this._dynamicStride * 4,\n                    offset: dynamicOffset * 4,\n                    format: property.format,\n                });\n                dynamicOffset += attributeInfo.size;\n            }\n            else\n            {\n                geometry.addAttribute(property.attributeName, {\n                    buffer: this._staticBuffer,\n                    stride: this._staticStride * 4,\n                    offset: staticOffset * 4,\n                    format: property.format,\n                });\n                staticOffset += attributeInfo.size;\n            }\n        }\n\n        geometry.addIndex(this.indexBuffer);\n\n        const uploadFunction = this.getParticleUpdate(properties);\n\n        this._dynamicUpload = uploadFunction.dynamicUpdate;\n        this._staticUpload = uploadFunction.staticUpdate;\n\n        this.geometry = geometry;\n    }\n\n    public getParticleUpdate(properties: Record<string, ParticleRendererProperty>)\n    {\n        const key = getParticleSyncKey(properties);\n\n        if (this._generateParticleUpdateCache[key])\n        {\n            return this._generateParticleUpdateCache[key];\n        }\n\n        this._generateParticleUpdateCache[key] = this.generateParticleUpdate(properties);\n\n        return this._generateParticleUpdateCache[key];\n    }\n\n    public generateParticleUpdate(properties: Record<string, ParticleRendererProperty>)\n    {\n        return generateParticleUpdateFunction(properties);\n    }\n\n    public update(particles: IParticle[], uploadStatic: boolean)\n    {\n        // first resize the buffers if needed!\n        // TODO resize!\n        if (particles.length > this._size)\n        {\n            uploadStatic = true;\n\n            this._size = Math.max(particles.length, (this._size * 1.5) | 0);\n\n            this.staticAttributeBuffer = new ViewableBuffer(this._size * this._staticStride * 4 * 4);\n            this.dynamicAttributeBuffer = new ViewableBuffer(this._size * this._dynamicStride * 4 * 4);\n            this.indexBuffer = createIndicesForQuads(this._size);\n\n            this.geometry.indexBuffer.setDataWithSize(\n                this.indexBuffer, this.indexBuffer.byteLength, true);\n        }\n\n        const dynamicAttributeBuffer = this.dynamicAttributeBuffer;\n\n        this._dynamicUpload(particles, dynamicAttributeBuffer.float32View, dynamicAttributeBuffer.uint32View);\n\n        this._dynamicBuffer.setDataWithSize(\n            this.dynamicAttributeBuffer.float32View, particles.length * this._dynamicStride * 4, true);\n\n        if (uploadStatic)\n        {\n            const staticAttributeBuffer = this.staticAttributeBuffer;\n\n            this._staticUpload(particles, staticAttributeBuffer.float32View, staticAttributeBuffer.uint32View);\n\n            this._staticBuffer.setDataWithSize(\n                staticAttributeBuffer.float32View, particles.length * this._staticStride * 4, true);\n        }\n    }\n\n    public destroy()\n    {\n        this._staticBuffer.destroy();\n        this._dynamicBuffer.destroy();\n        this.geometry.destroy();\n    }\n}\n\nfunction getParticleSyncKey(properties: Record<string, ParticleRendererProperty>)\n{\n    const keyGen: string[] = [];\n\n    for (const key in properties)\n    {\n        const property = properties[key];\n\n        keyGen.push(key, property.code, property.dynamic ? 'd' : 's');\n    }\n\n    return keyGen.join('_');\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}