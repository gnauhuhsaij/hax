{"ast":null,"code":"import { ExtensionType } from '../extensions/Extensions.mjs';\nimport { Matrix } from '../maths/matrix/Matrix.mjs';\nimport { Point } from '../maths/point/Point.mjs';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup.mjs';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry.mjs';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture.mjs';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { RendererType } from '../rendering/renderers/types.mjs';\nimport { Bounds } from '../scene/container/bounds/Bounds.mjs';\nimport { getFastGlobalBounds } from '../scene/container/bounds/getFastGlobalBounds.mjs';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds.mjs';\nimport { warn } from '../utils/logging/warn.mjs';\n\"use strict\";\nconst quadGeometry = new Geometry({\n  attributes: {\n    aPosition: {\n      buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n      format: \"float32x2\",\n      stride: 2 * 4,\n      offset: 0\n    }\n  },\n  indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])\n});\nclass FilterSystem {\n  constructor(renderer) {\n    this._filterStackIndex = 0;\n    this._filterStack = [];\n    this._filterGlobalUniforms = new UniformGroup({\n      uInputSize: {\n        value: new Float32Array(4),\n        type: \"vec4<f32>\"\n      },\n      uInputPixel: {\n        value: new Float32Array(4),\n        type: \"vec4<f32>\"\n      },\n      uInputClamp: {\n        value: new Float32Array(4),\n        type: \"vec4<f32>\"\n      },\n      uOutputFrame: {\n        value: new Float32Array(4),\n        type: \"vec4<f32>\"\n      },\n      uGlobalFrame: {\n        value: new Float32Array(4),\n        type: \"vec4<f32>\"\n      },\n      uOutputTexture: {\n        value: new Float32Array(4),\n        type: \"vec4<f32>\"\n      }\n    });\n    this._globalFilterBindGroup = new BindGroup({});\n    this.renderer = renderer;\n  }\n  /**\n   * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n   * @readonly\n   */\n  get activeBackTexture() {\n    return this._activeFilterData?.backTexture;\n  }\n  push(instruction) {\n    const renderer = this.renderer;\n    const filters = instruction.filterEffect.filters;\n    if (!this._filterStack[this._filterStackIndex]) {\n      this._filterStack[this._filterStackIndex] = this._getFilterData();\n    }\n    const filterData = this._filterStack[this._filterStackIndex];\n    this._filterStackIndex++;\n    if (filters.length === 0) {\n      filterData.skip = true;\n      return;\n    }\n    const bounds = filterData.bounds;\n    if (instruction.renderables) {\n      getGlobalRenderableBounds(instruction.renderables, bounds);\n    } else if (instruction.filterEffect.filterArea) {\n      bounds.clear();\n      bounds.addRect(instruction.filterEffect.filterArea);\n      bounds.applyMatrix(instruction.container.worldTransform);\n    } else {\n      getFastGlobalBounds(instruction.container, bounds);\n    }\n    const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n    let resolution = Infinity;\n    let padding = 0;\n    let antialias = true;\n    let blendRequired = false;\n    let enabled = false;\n    let clipToViewport = true;\n    for (let i = 0; i < filters.length; i++) {\n      const filter = filters[i];\n      resolution = Math.min(resolution, filter.resolution === \"inherit\" ? colorTextureSource._resolution : filter.resolution);\n      padding += filter.padding;\n      if (filter.antialias === \"off\") {\n        antialias = false;\n      } else if (filter.antialias === \"inherit\") {\n        antialias && (antialias = colorTextureSource.antialias);\n      }\n      if (!filter.clipToViewport) {\n        clipToViewport = false;\n      }\n      const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n      if (!isCompatible) {\n        enabled = false;\n        break;\n      }\n      if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {\n        warn(\"Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.\");\n        enabled = false;\n        break;\n      }\n      enabled = filter.enabled || enabled;\n      blendRequired = blendRequired || filter.blendRequired;\n    }\n    if (!enabled) {\n      filterData.skip = true;\n      return;\n    }\n    bounds.scale(resolution);\n    if (clipToViewport) {\n      const viewPort = renderer.renderTarget.rootViewPort;\n      bounds.fitBounds(0, viewPort.width, 0, viewPort.height);\n    }\n    bounds.ceil().scale(1 / resolution).pad(padding | 0);\n    if (!bounds.isPositive) {\n      filterData.skip = true;\n      return;\n    }\n    filterData.skip = false;\n    filterData.bounds = bounds;\n    filterData.blendRequired = blendRequired;\n    filterData.container = instruction.container;\n    filterData.filterEffect = instruction.filterEffect;\n    filterData.previousRenderSurface = renderer.renderTarget.renderSurface;\n    filterData.inputTexture = TexturePool.getOptimalTexture(bounds.width, bounds.height, resolution, antialias);\n    renderer.renderTarget.bind(filterData.inputTexture, true);\n    renderer.globalUniforms.push({\n      offset: bounds\n    });\n  }\n  pop() {\n    const renderer = this.renderer;\n    this._filterStackIndex--;\n    const filterData = this._filterStack[this._filterStackIndex];\n    if (filterData.skip) {\n      return;\n    }\n    this._activeFilterData = filterData;\n    const inputTexture = filterData.inputTexture;\n    const bounds = filterData.bounds;\n    let backTexture = Texture.EMPTY;\n    renderer.renderTarget.finishRenderPass();\n    if (filterData.blendRequired) {\n      const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;\n      const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);\n      backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);\n    }\n    filterData.backTexture = backTexture;\n    const filters = filterData.filterEffect.filters;\n    this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n    this._globalFilterBindGroup.setResource(backTexture.source, 3);\n    renderer.globalUniforms.pop();\n    if (filters.length === 1) {\n      filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);\n      TexturePool.returnTexture(inputTexture);\n    } else {\n      let flip = filterData.inputTexture;\n      let flop = TexturePool.getOptimalTexture(bounds.width, bounds.height, flip.source._resolution, false);\n      let i = 0;\n      for (i = 0; i < filters.length - 1; ++i) {\n        const filter = filters[i];\n        filter.apply(this, flip, flop, true);\n        const t = flip;\n        flip = flop;\n        flop = t;\n      }\n      filters[i].apply(this, flip, filterData.previousRenderSurface, false);\n      TexturePool.returnTexture(flip);\n      TexturePool.returnTexture(flop);\n    }\n    if (filterData.blendRequired) {\n      TexturePool.returnTexture(backTexture);\n    }\n  }\n  getBackTexture(lastRenderSurface, bounds, previousBounds) {\n    const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n    const backTexture = TexturePool.getOptimalTexture(bounds.width, bounds.height, backgroundResolution, false);\n    let x = bounds.minX;\n    let y = bounds.minY;\n    if (previousBounds) {\n      x -= previousBounds.minX;\n      y -= previousBounds.minY;\n    }\n    x = Math.floor(x * backgroundResolution);\n    y = Math.floor(y * backgroundResolution);\n    const width = Math.ceil(bounds.width * backgroundResolution);\n    const height = Math.ceil(bounds.height * backgroundResolution);\n    this.renderer.renderTarget.copyToTexture(lastRenderSurface, backTexture, {\n      x,\n      y\n    }, {\n      width,\n      height\n    }, {\n      x: 0,\n      y: 0\n    });\n    return backTexture;\n  }\n  applyFilter(filter, input, output, clear) {\n    const renderer = this.renderer;\n    const filterData = this._filterStack[this._filterStackIndex];\n    const bounds = filterData.bounds;\n    const offset = Point.shared;\n    const previousRenderSurface = filterData.previousRenderSurface;\n    const isFinalTarget = previousRenderSurface === output;\n    let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n    let currentIndex = this._filterStackIndex - 1;\n    while (currentIndex > 0 && this._filterStack[currentIndex].skip) {\n      --currentIndex;\n    }\n    if (currentIndex > 0) {\n      resolution = this._filterStack[currentIndex].inputTexture.source._resolution;\n    }\n    const filterUniforms = this._filterGlobalUniforms;\n    const uniforms = filterUniforms.uniforms;\n    const outputFrame = uniforms.uOutputFrame;\n    const inputSize = uniforms.uInputSize;\n    const inputPixel = uniforms.uInputPixel;\n    const inputClamp = uniforms.uInputClamp;\n    const globalFrame = uniforms.uGlobalFrame;\n    const outputTexture = uniforms.uOutputTexture;\n    if (isFinalTarget) {\n      let lastIndex = this._filterStackIndex;\n      while (lastIndex > 0) {\n        lastIndex--;\n        const filterData2 = this._filterStack[this._filterStackIndex - 1];\n        if (!filterData2.skip) {\n          offset.x = filterData2.bounds.minX;\n          offset.y = filterData2.bounds.minY;\n          break;\n        }\n      }\n      outputFrame[0] = bounds.minX - offset.x;\n      outputFrame[1] = bounds.minY - offset.y;\n    } else {\n      outputFrame[0] = 0;\n      outputFrame[1] = 0;\n    }\n    outputFrame[2] = input.frame.width;\n    outputFrame[3] = input.frame.height;\n    inputSize[0] = input.source.width;\n    inputSize[1] = input.source.height;\n    inputSize[2] = 1 / inputSize[0];\n    inputSize[3] = 1 / inputSize[1];\n    inputPixel[0] = input.source.pixelWidth;\n    inputPixel[1] = input.source.pixelHeight;\n    inputPixel[2] = 1 / inputPixel[0];\n    inputPixel[3] = 1 / inputPixel[1];\n    inputClamp[0] = 0.5 * inputPixel[2];\n    inputClamp[1] = 0.5 * inputPixel[3];\n    inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];\n    inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];\n    const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n    globalFrame[0] = offset.x * resolution;\n    globalFrame[1] = offset.y * resolution;\n    globalFrame[2] = rootTexture.source.width * resolution;\n    globalFrame[3] = rootTexture.source.height * resolution;\n    const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n    renderer.renderTarget.bind(output, !!clear);\n    if (output instanceof Texture) {\n      outputTexture[0] = output.frame.width;\n      outputTexture[1] = output.frame.height;\n    } else {\n      outputTexture[0] = renderTarget.width;\n      outputTexture[1] = renderTarget.height;\n    }\n    outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n    filterUniforms.update();\n    if (renderer.renderPipes.uniformBatch) {\n      const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(filterUniforms);\n      this._globalFilterBindGroup.setResource(batchUniforms, 0);\n    } else {\n      this._globalFilterBindGroup.setResource(filterUniforms, 0);\n    }\n    this._globalFilterBindGroup.setResource(input.source, 1);\n    this._globalFilterBindGroup.setResource(input.source.style, 2);\n    filter.groups[0] = this._globalFilterBindGroup;\n    renderer.encoder.draw({\n      geometry: quadGeometry,\n      shader: filter,\n      state: filter._state,\n      topology: \"triangle-list\"\n    });\n    if (renderer.type === RendererType.WEBGL) {\n      renderer.renderTarget.finishRenderPass();\n    }\n  }\n  _getFilterData() {\n    return {\n      skip: false,\n      inputTexture: null,\n      bounds: new Bounds(),\n      container: null,\n      filterEffect: null,\n      blendRequired: false,\n      previousRenderSurface: null\n    };\n  }\n  /**\n   * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n   *\n   * Use `outputMatrix * vTextureCoord` in the shader.\n   * @param outputMatrix - The matrix to output to.\n   * @param {Sprite} sprite - The sprite to map to.\n   * @returns The mapped matrix.\n   */\n  calculateSpriteMatrix(outputMatrix, sprite) {\n    const data = this._activeFilterData;\n    const mappedMatrix = outputMatrix.set(data.inputTexture._source.width, 0, 0, data.inputTexture._source.height, data.bounds.minX, data.bounds.minY);\n    const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n    worldTransform.invert();\n    mappedMatrix.prepend(worldTransform);\n    mappedMatrix.scale(1 / sprite.texture.frame.width, 1 / sprite.texture.frame.height);\n    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n    return mappedMatrix;\n  }\n}\n/** @ignore */\nFilterSystem.extension = {\n  type: [ExtensionType.WebGLSystem, ExtensionType.WebGPUSystem],\n  name: \"filter\"\n};\nexport { FilterSystem };","map":{"version":3,"names":["quadGeometry","Geometry","attributes","aPosition","buffer","Float32Array","format","stride","offset","indexBuffer","Uint32Array","FilterSystem","constructor","renderer","_filterStackIndex","_filterStack","_filterGlobalUniforms","UniformGroup","uInputSize","value","type","uInputPixel","uInputClamp","uOutputFrame","uGlobalFrame","uOutputTexture","_globalFilterBindGroup","BindGroup","activeBackTexture","_activeFilterData","backTexture","push","instruction","filters","filterEffect","_getFilterData","filterData","length","skip","bounds","renderables","getGlobalRenderableBounds","filterArea","clear","addRect","applyMatrix","container","worldTransform","getFastGlobalBounds","colorTextureSource","renderTarget","colorTexture","source","resolution","Infinity","padding","antialias","blendRequired","enabled","clipToViewport","i","filter","Math","min","_resolution","isCompatible","compatibleRenderers","backBuffer","useBackBuffer","warn","scale","viewPort","rootViewPort","fitBounds","width","height","ceil","pad","isPositive","previousRenderSurface","renderSurface","inputTexture","TexturePool","getOptimalTexture","bind","globalUniforms","pop","Texture","EMPTY","finishRenderPass","previousBounds","getRenderTarget","getBackTexture","setResource","style","apply","returnTexture","flip","flop","t","lastRenderSurface","backgroundResolution","x","minX","y","minY","floor","copyToTexture","applyFilter","input","output","Point","shared","isFinalTarget","rootRenderTarget","currentIndex","filterUniforms","uniforms","outputFrame","inputSize","inputPixel","inputClamp","globalFrame","outputTexture","lastIndex","filterData2","frame","pixelWidth","pixelHeight","rootTexture","isRoot","update","renderPipes","uniformBatch","batchUniforms","getUboResource","groups","encoder","draw","geometry","shader","state","_state","topology","RendererType","WEBGL","Bounds","calculateSpriteMatrix","outputMatrix","sprite","data","mappedMatrix","set","_source","copyTo","Matrix","invert","prepend","texture","translate","anchor","extension","ExtensionType","WebGLSystem","WebGPUSystem","name"],"sources":["/Users/huangjiashu/Desktop/AI Projects/node_modules/pixi.js/src/filters/FilterSystem.ts"],"sourcesContent":["import { ExtensionType } from '../extensions/Extensions';\nimport { Matrix } from '../maths/matrix/Matrix';\nimport { Point } from '../maths/point/Point';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../rendering/renderers/types';\nimport { Bounds } from '../scene/container/bounds/Bounds';\nimport { getFastGlobalBounds } from '../scene/container/bounds/getFastGlobalBounds';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds';\nimport { warn } from '../utils/logging/warn';\n\nimport type { WebGLRenderer } from '../rendering/renderers/gl/WebGLRenderer';\nimport type { WebGPURenderer } from '../rendering/renderers/gpu/WebGPURenderer';\nimport type { Instruction } from '../rendering/renderers/shared/instructions/Instruction';\nimport type { Renderable } from '../rendering/renderers/shared/Renderable';\nimport type { RenderTarget } from '../rendering/renderers/shared/renderTarget/RenderTarget';\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Container } from '../scene/container/Container';\nimport type { Sprite } from '../scene/sprite/Sprite';\nimport type { Filter } from './Filter';\nimport type { FilterEffect } from './FilterEffect';\n\ntype FilterAction = 'pushFilter' | 'popFilter';\n\n//\nconst quadGeometry = new Geometry({\n    attributes: {\n        aPosition: {\n            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            format: 'float32x2',\n            stride: 2 * 4,\n            offset: 0,\n        },\n    },\n    indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\n/**\n * The filter pipeline is responsible for applying filters scene items!\n *\n * KNOWN BUGS:\n * 1. Global bounds calculation is incorrect if it is used when flip flopping filters. The maths can be found below\n * eg: filters [noiseFilter, blurFilter] noiseFilter will calculate the global bounds incorrectly.\n *\n * 2. RenderGroups do not work with filters. This is because the renderGroup matrix is not currently taken into account.\n *\n * Implementation notes:\n * 1. Gotcha - nesting filters that require blending will not work correctly. This creates a chicken and egg problem\n * the complexity and performance required to do this is not worth it i feel.. but lets see if others agree!\n *\n * 2. Filters are designed to be changed on the fly, this is means that changing filter information each frame will\n * not trigger an instruction rebuild. If you are constantly turning a filter on and off.. its therefore better to set\n * enabled to true or false on the filter. Or setting an empty array.\n *\n * 3. Need to look at perhaps aliasing when flip flopping filters. Really we should only need to antialias the FIRST\n * Texture we render too. The rest can be non aliased. This might help performance.\n * Currently we flip flop with an antialiased texture if antialiasing is enabled on the filter.\n */\nexport interface FilterInstruction extends Instruction\n{\n    renderPipeId: 'filter',\n    action: FilterAction,\n    container?: Container,\n    renderables?: Renderable[],\n    filterEffect: FilterEffect,\n}\n\nexport interface FilterData\n{\n    skip: boolean;\n    enabledLength?: number;\n    inputTexture: Texture\n    bounds: Bounds,\n    blendRequired: boolean,\n    container: Container,\n    filterEffect: FilterEffect,\n    previousRenderSurface: RenderSurface,\n    backTexture?: Texture,\n}\n\n/**\n * System that manages the filter pipeline\n * @memberof rendering\n */\nexport class FilterSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'filter',\n    } as const;\n\n    public readonly renderer: Renderer;\n\n    private _filterStackIndex = 0;\n    private _filterStack: FilterData[] = [];\n\n    private readonly _filterGlobalUniforms = new UniformGroup({\n        uInputSize: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputPixel: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputClamp: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uGlobalFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputTexture: { value: new Float32Array(4), type: 'vec4<f32>' },\n    });\n\n    private readonly _globalFilterBindGroup: BindGroup = new BindGroup({});\n    private _activeFilterData: FilterData;\n\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n     * @readonly\n     */\n    public get activeBackTexture(): Texture | undefined\n    {\n        return this._activeFilterData?.backTexture;\n    }\n\n    public push(instruction: FilterInstruction)\n    {\n        const renderer = this.renderer;\n\n        const filters = instruction.filterEffect.filters;\n\n        if (!this._filterStack[this._filterStackIndex])\n        {\n            this._filterStack[this._filterStackIndex] = this._getFilterData();\n        }\n\n        // get a filter data from the stack. They can be reused multiple times each frame,\n        // so we don't need to worry about overwriting them in a single pass.\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        this._filterStackIndex++;\n\n        // if there are no filters, we skip the pass\n        if (filters.length === 0)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        const bounds: Bounds = filterData.bounds;\n\n        // this path is used by the blend modes mostly!\n        // they collect all renderables and push them into a list.\n        // this list is then used to calculate the bounds of the filter area\n        if (instruction.renderables)\n        {\n            getGlobalRenderableBounds(instruction.renderables, bounds);\n        }\n        // if a filterArea is provided, we save our selves some measuring and just use that area supplied\n        else if (instruction.filterEffect.filterArea)\n        {\n            bounds.clear();\n\n            // transform the filterArea into global space..\n            bounds.addRect(instruction.filterEffect.filterArea);\n\n            // new for v8, we transform the bounds into the space of the container\n            bounds.applyMatrix(instruction.container.worldTransform);\n        }\n        // classic filter path, we get the bounds of the container and use it by recursively\n        // measuring.\n        else\n        {\n            getFastGlobalBounds(instruction.container, bounds);\n        }\n        // get GLOBAL bounds of the item we are going to apply the filter to\n\n        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n\n        // next we get the settings for the filter\n        // we need to find the LOWEST resolution for the filter list\n        let resolution = Infinity;\n        // Padding is additive to add padding to our padding\n        let padding = 0;\n        // if this is true for all filter, it should be true, and otherwise false\n        let antialias = true;\n        // true if any filter requires the previous render target\n        let blendRequired = false;\n        // true if any filter in the list is enabled\n        let enabled = false;\n        // false if any filter in the list has false\n        let clipToViewport = true;\n\n        for (let i = 0; i < filters.length; i++)\n        {\n            const filter = filters[i];\n\n            resolution = Math.min(resolution, filter.resolution === 'inherit'\n                ? colorTextureSource._resolution : filter.resolution);\n            padding += filter.padding;\n\n            if (filter.antialias === 'off')\n            {\n                antialias = false;\n            }\n            else if (filter.antialias === 'inherit')\n            {\n                antialias &&= colorTextureSource.antialias;\n            }\n\n            if (!filter.clipToViewport)\n            {\n                clipToViewport = false;\n            }\n\n            const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n\n            if (!isCompatible)\n            {\n                enabled = false;\n                break;\n            }\n\n            if (filter.blendRequired && !((renderer as WebGLRenderer).backBuffer?.useBackBuffer ?? true))\n            {\n                // #if _DEBUG\n                // eslint-disable-next-line max-len\n                warn('Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.');\n                // #endif\n\n                enabled = false;\n                break;\n            }\n\n            enabled = filter.enabled || enabled;\n            blendRequired = blendRequired || filter.blendRequired;\n        }\n\n        // if no filters are enabled lets skip!\n        if (!enabled)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // here we constrain the bounds to the viewport we will render too\n        // this should not take into account the x, y offset of the viewport - as this is\n        // handled by the viewport on the gpu.\n        // need to factor in resolutions also..\n        bounds\n            .scale(resolution);\n\n        if (clipToViewport)\n        {\n            const viewPort = renderer.renderTarget.rootViewPort;\n\n            bounds.fitBounds(0, viewPort.width, 0, viewPort.height);\n        }\n\n        bounds\n            .ceil()\n            .scale(1 / resolution)\n            .pad(padding | 0);\n\n        // skip if the bounds are negative or zero as this means they are\n        // not visible on the screen\n        if (!bounds.isPositive)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // set all the filter data\n        filterData.skip = false;\n\n        filterData.bounds = bounds;\n        filterData.blendRequired = blendRequired;\n        filterData.container = instruction.container;\n        filterData.filterEffect = instruction.filterEffect;\n\n        filterData.previousRenderSurface = renderer.renderTarget.renderSurface;\n\n        // bind...\n        // get a P02 texture from our pool...\n        filterData.inputTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            resolution,\n            antialias,\n        );\n\n        renderer.renderTarget.bind(filterData.inputTexture, true);\n        // set the global uniforms to take into account the bounds offset required\n\n        renderer.globalUniforms.push({\n            offset: bounds,\n        });\n    }\n\n    public pop()\n    {\n        const renderer = this.renderer;\n\n        this._filterStackIndex--;\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        // if we are skipping this filter then we just do nothing :D\n        if (filterData.skip)\n        {\n            return;\n        }\n\n        this._activeFilterData = filterData;\n\n        const inputTexture = filterData.inputTexture;\n\n        const bounds = filterData.bounds;\n\n        let backTexture = Texture.EMPTY;\n\n        renderer.renderTarget.finishRenderPass();\n\n        if (filterData.blendRequired)\n        {\n            // this actually forces the current commandQueue to render everything so far.\n            // if we don't do this, we won't be able to copy pixels for the background\n            const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;\n\n            const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);\n\n            backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);\n        }\n\n        filterData.backTexture = backTexture;\n\n        const filters = filterData.filterEffect.filters;\n\n        // get a BufferResource from the uniformBatch.\n        // this will batch the shader uniform data and give us a buffer resource we can\n        // set on our globalUniform Bind Group\n        // eslint-disable-next-line max-len\n\n        // update the resources on the bind group...\n        this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n        this._globalFilterBindGroup.setResource(backTexture.source, 3);\n\n        renderer.globalUniforms.pop();\n\n        if (filters.length === 1)\n        {\n            // render a single filter...\n            // this.applyFilter(filters[0], inputTexture, filterData.previousRenderSurface, false);\n            filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);\n\n            // return the texture to the pool so we can reuse the next frame\n            TexturePool.returnTexture(inputTexture);\n        }\n        else\n        {\n            let flip = filterData.inputTexture;\n\n            // get another texture that we will render the next filter too\n            let flop = TexturePool.getOptimalTexture(\n                bounds.width,\n                bounds.height,\n                flip.source._resolution,\n                false\n            );\n\n            let i = 0;\n\n            // loop and apply the filters, omitting the last one as we will render that to the final target\n            for (i = 0; i < filters.length - 1; ++i)\n            {\n                const filter = filters[i];\n\n                filter.apply(this, flip, flop, true);\n                const t = flip;\n\n                flip = flop;\n                flop = t;\n            }\n\n            filters[i].apply(this, flip, filterData.previousRenderSurface, false);\n\n            // return those textures for later!\n            TexturePool.returnTexture(flip);\n            TexturePool.returnTexture(flop);\n        }\n\n        // if we made a background texture, lets return that also\n        if (filterData.blendRequired)\n        {\n            TexturePool.returnTexture(backTexture);\n        }\n    }\n\n    public getBackTexture(lastRenderSurface: RenderTarget, bounds: Bounds, previousBounds?: Bounds)\n    {\n        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n\n        const backTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            backgroundResolution,\n            false,\n        );\n\n        let x = bounds.minX;\n        let y = bounds.minY;\n\n        if (previousBounds)\n        {\n            x -= previousBounds.minX;\n            y -= previousBounds.minY;\n        }\n\n        x = Math.floor(x * backgroundResolution);\n        y = Math.floor(y * backgroundResolution);\n\n        const width = Math.ceil(bounds.width * backgroundResolution);\n        const height = Math.ceil(bounds.height * backgroundResolution);\n\n        this.renderer.renderTarget.copyToTexture(\n            lastRenderSurface,\n            backTexture,\n            { x, y },\n            { width, height },\n            { x: 0, y: 0 }\n        );\n\n        return backTexture;\n    }\n\n    public applyFilter(filter: Filter, input: Texture, output: RenderSurface, clear: boolean)\n    {\n        const renderer = this.renderer;\n\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        const bounds = filterData.bounds;\n\n        const offset = Point.shared;\n        const previousRenderSurface = filterData.previousRenderSurface;\n\n        const isFinalTarget = previousRenderSurface === output;\n\n        let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n\n        // to find the previous resolution we need to account for the skipped filters\n        // the following will find the last non skipped filter...\n        let currentIndex = this._filterStackIndex - 1;\n\n        while (currentIndex > 0 && this._filterStack[currentIndex].skip)\n        {\n            --currentIndex;\n        }\n\n        if (currentIndex > 0)\n        {\n            resolution = this._filterStack[currentIndex].inputTexture.source._resolution;\n        }\n\n        const filterUniforms = this._filterGlobalUniforms;\n        const uniforms = filterUniforms.uniforms;\n\n        const outputFrame = uniforms.uOutputFrame;\n        const inputSize = uniforms.uInputSize;\n        const inputPixel = uniforms.uInputPixel;\n        const inputClamp = uniforms.uInputClamp;\n        const globalFrame = uniforms.uGlobalFrame;\n        const outputTexture = uniforms.uOutputTexture;\n\n        // are we rendering back to the original surface?\n        if (isFinalTarget)\n        {\n            let lastIndex = this._filterStackIndex;\n\n            // get previous bounds.. we must take into account skipped filters also..\n            while (lastIndex > 0)\n            {\n                lastIndex--;\n                const filterData = this._filterStack[this._filterStackIndex - 1];\n\n                if (!filterData.skip)\n                {\n                    offset.x = filterData.bounds.minX;\n                    offset.y = filterData.bounds.minY;\n\n                    break;\n                }\n            }\n\n            outputFrame[0] = bounds.minX - offset.x;\n            outputFrame[1] = bounds.minY - offset.y;\n        }\n        else\n        {\n            outputFrame[0] = 0;\n            outputFrame[1] = 0;\n        }\n\n        outputFrame[2] = input.frame.width;\n        outputFrame[3] = input.frame.height;\n\n        inputSize[0] = input.source.width;\n        inputSize[1] = input.source.height;\n        inputSize[2] = 1 / inputSize[0];\n        inputSize[3] = 1 / inputSize[1];\n\n        inputPixel[0] = input.source.pixelWidth;\n        inputPixel[1] = input.source.pixelHeight;\n        inputPixel[2] = 1.0 / inputPixel[0];\n        inputPixel[3] = 1.0 / inputPixel[1];\n\n        inputClamp[0] = 0.5 * inputPixel[2];\n        inputClamp[1] = 0.5 * inputPixel[3];\n        inputClamp[2] = (input.frame.width * inputSize[2]) - (0.5 * inputPixel[2]);\n        inputClamp[3] = (input.frame.height * inputSize[3]) - (0.5 * inputPixel[3]);\n\n        const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n\n        globalFrame[0] = offset.x * resolution;\n        globalFrame[1] = offset.y * resolution;\n\n        globalFrame[2] = rootTexture.source.width * resolution;\n        globalFrame[3] = rootTexture.source.height * resolution;\n\n        // set the output texture - this is where we are going to render to\n\n        const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n\n        renderer.renderTarget.bind(output, !!clear);\n\n        if (output instanceof Texture)\n        {\n            outputTexture[0] = output.frame.width;\n            outputTexture[1] = output.frame.height;\n        }\n        else\n        {\n            // this means a renderTarget was passed directly\n            outputTexture[0] = renderTarget.width;\n            outputTexture[1] = renderTarget.height;\n        }\n\n        outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n        filterUniforms.update();\n\n        // TODO - should prolly use a adaptor...\n        if ((renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            const batchUniforms = (renderer as WebGPURenderer).renderPipes.uniformBatch\n                .getUboResource(filterUniforms);\n\n            this._globalFilterBindGroup.setResource(batchUniforms, 0);\n        }\n        else\n        {\n            this._globalFilterBindGroup.setResource(filterUniforms, 0);\n        }\n\n        // now lets update the output texture...\n\n        // set bind group..\n        this._globalFilterBindGroup.setResource(input.source, 1);\n        this._globalFilterBindGroup.setResource(input.source.style, 2);\n\n        filter.groups[0] = this._globalFilterBindGroup;\n\n        renderer.encoder.draw({\n            geometry: quadGeometry,\n            shader: filter,\n            state: filter._state,\n            topology: 'triangle-list'\n        });\n\n        // WebGPU blit's automatically, but WebGL does not!\n        if (renderer.type === RendererType.WEBGL)\n        {\n            renderer.renderTarget.finishRenderPass();\n        }\n    }\n\n    private _getFilterData(): FilterData\n    {\n        return {\n            skip: false,\n            inputTexture: null,\n            bounds: new Bounds(),\n            container: null,\n            filterEffect: null,\n            blendRequired: false,\n            previousRenderSurface: null,\n        };\n    }\n\n    /**\n     * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n     *\n     * Use `outputMatrix * vTextureCoord` in the shader.\n     * @param outputMatrix - The matrix to output to.\n     * @param {Sprite} sprite - The sprite to map to.\n     * @returns The mapped matrix.\n     */\n    public calculateSpriteMatrix(outputMatrix: Matrix, sprite: Sprite): Matrix\n    {\n        const data = this._activeFilterData;\n\n        const mappedMatrix = outputMatrix.set(\n            data.inputTexture._source.width,\n            0, 0,\n            data.inputTexture._source.height,\n            data.bounds.minX, data.bounds.minY\n        );\n\n        const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n\n        worldTransform.invert();\n        mappedMatrix.prepend(worldTransform);\n        mappedMatrix.scale(\n            1.0 / sprite.texture.frame.width,\n            1.0 / sprite.texture.frame.height\n        );\n\n        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n        return mappedMatrix;\n    }\n\n    public destroy?: () => void;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}