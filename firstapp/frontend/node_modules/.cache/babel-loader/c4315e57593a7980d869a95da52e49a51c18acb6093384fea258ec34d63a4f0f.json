{"ast":null,"code":"import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { FilterEffect } from '../../../filters/FilterEffect.mjs';\nimport { MaskFilter } from '../../../filters/mask/MaskFilter.mjs';\nimport { Bounds } from '../../../scene/container/bounds/Bounds.mjs';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds.mjs';\nimport { collectAllRenderables } from '../../../scene/container/utils/buildInstructions.mjs';\nimport { Sprite } from '../../../scene/sprite/Sprite.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { Texture } from '../../renderers/shared/texture/Texture.mjs';\nimport { TexturePool } from '../../renderers/shared/texture/TexturePool.mjs';\nimport { RendererType } from '../../renderers/types.mjs';\n\"use strict\";\nconst tempBounds = new Bounds();\nclass AlphaMaskEffect extends FilterEffect {\n  constructor() {\n    super();\n    this.filters = [new MaskFilter({\n      sprite: new Sprite(Texture.EMPTY),\n      inverse: false,\n      resolution: \"inherit\",\n      antialias: \"inherit\"\n    })];\n  }\n  get sprite() {\n    return this.filters[0].sprite;\n  }\n  set sprite(value) {\n    this.filters[0].sprite = value;\n  }\n  get inverse() {\n    return this.filters[0].inverse;\n  }\n  set inverse(value) {\n    this.filters[0].inverse = value;\n  }\n}\nclass AlphaMaskPipe {\n  constructor(renderer) {\n    this._activeMaskStage = [];\n    this._renderer = renderer;\n  }\n  push(mask, maskedContainer, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"alphaMask\",\n      action: \"pushMaskBegin\",\n      mask,\n      inverse: maskedContainer._maskOptions.inverse,\n      canBundle: false,\n      maskedContainer\n    });\n    mask.inverse = maskedContainer._maskOptions.inverse;\n    if (mask.renderMaskToTexture) {\n      const maskContainer = mask.mask;\n      maskContainer.includeInBuild = true;\n      collectAllRenderables(maskContainer, instructionSet, renderer);\n      maskContainer.includeInBuild = false;\n    }\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"alphaMask\",\n      action: \"pushMaskEnd\",\n      mask,\n      maskedContainer,\n      inverse: maskedContainer._maskOptions.inverse,\n      canBundle: false\n    });\n  }\n  pop(mask, _maskedContainer, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"alphaMask\",\n      action: \"popMaskEnd\",\n      mask,\n      inverse: _maskedContainer._maskOptions.inverse,\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    const renderer = this._renderer;\n    const renderMask = instruction.mask.renderMaskToTexture;\n    if (instruction.action === \"pushMaskBegin\") {\n      const filterEffect = BigPool.get(AlphaMaskEffect);\n      filterEffect.inverse = instruction.inverse;\n      if (renderMask) {\n        instruction.mask.mask.measurable = true;\n        const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds);\n        instruction.mask.mask.measurable = false;\n        bounds.ceil();\n        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n        const filterTexture = TexturePool.getOptimalTexture(bounds.width, bounds.height, colorTextureSource._resolution, colorTextureSource.antialias);\n        renderer.renderTarget.push(filterTexture, true);\n        renderer.globalUniforms.push({\n          offset: bounds,\n          worldColor: 4294967295\n        });\n        const sprite = filterEffect.sprite;\n        sprite.texture = filterTexture;\n        sprite.worldTransform.tx = bounds.minX;\n        sprite.worldTransform.ty = bounds.minY;\n        this._activeMaskStage.push({\n          filterEffect,\n          maskedContainer: instruction.maskedContainer,\n          filterTexture\n        });\n      } else {\n        filterEffect.sprite = instruction.mask.mask;\n        this._activeMaskStage.push({\n          filterEffect,\n          maskedContainer: instruction.maskedContainer\n        });\n      }\n    } else if (instruction.action === \"pushMaskEnd\") {\n      const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];\n      if (renderMask) {\n        if (renderer.type === RendererType.WEBGL) {\n          renderer.renderTarget.finishRenderPass();\n        }\n        renderer.renderTarget.pop();\n        renderer.globalUniforms.pop();\n      }\n      renderer.filter.push({\n        renderPipeId: \"filter\",\n        action: \"pushFilter\",\n        container: maskData.maskedContainer,\n        filterEffect: maskData.filterEffect,\n        canBundle: false\n      });\n    } else if (instruction.action === \"popMaskEnd\") {\n      renderer.filter.pop();\n      const maskData = this._activeMaskStage.pop();\n      if (renderMask) {\n        TexturePool.returnTexture(maskData.filterTexture);\n      }\n      BigPool.return(maskData.filterEffect);\n    }\n  }\n  destroy() {\n    this._renderer = null;\n    this._activeMaskStage = null;\n  }\n}\n/** @ignore */\nAlphaMaskPipe.extension = {\n  type: [ExtensionType.WebGLPipes, ExtensionType.WebGPUPipes, ExtensionType.CanvasPipes],\n  name: \"alphaMask\"\n};\nexport { AlphaMaskPipe };","map":{"version":3,"names":["tempBounds","Bounds","AlphaMaskEffect","FilterEffect","constructor","filters","MaskFilter","sprite","Sprite","Texture","EMPTY","inverse","resolution","antialias","value","AlphaMaskPipe","renderer","_activeMaskStage","_renderer","push","mask","maskedContainer","instructionSet","renderPipes","batch","break","add","renderPipeId","action","_maskOptions","canBundle","renderMaskToTexture","maskContainer","includeInBuild","collectAllRenderables","pop","_maskedContainer","execute","instruction","renderMask","filterEffect","BigPool","get","measurable","bounds","getGlobalBounds","ceil","colorTextureSource","renderTarget","colorTexture","source","filterTexture","TexturePool","getOptimalTexture","width","height","_resolution","globalUniforms","offset","worldColor","texture","worldTransform","tx","minX","ty","minY","maskData","length","type","RendererType","WEBGL","finishRenderPass","filter","container","returnTexture","return","destroy","extension","ExtensionType","WebGLPipes","WebGPUPipes","CanvasPipes","name"],"sources":["/Users/huangjiashu/Desktop/AI Projects/node_modules/pixi.js/src/rendering/mask/alpha/AlphaMaskPipe.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { FilterEffect } from '../../../filters/FilterEffect';\nimport { MaskFilter } from '../../../filters/mask/MaskFilter';\nimport { Bounds } from '../../../scene/container/bounds/Bounds';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds';\nimport { collectAllRenderables } from '../../../scene/container/utils/buildInstructions';\nimport { Sprite } from '../../../scene/sprite/Sprite';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { Texture } from '../../renderers/shared/texture/Texture';\nimport { TexturePool } from '../../renderers/shared/texture/TexturePool';\nimport { RendererType } from '../../renderers/types';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { RenderTarget } from '../../renderers/shared/renderTarget/RenderTarget';\nimport type { Renderer } from '../../renderers/types';\nimport type { AlphaMask } from './AlphaMask';\n\ntype MaskMode = 'pushMaskBegin' | 'pushMaskEnd' | 'popMaskBegin' | 'popMaskEnd';\n\nconst tempBounds = new Bounds();\n\nclass AlphaMaskEffect extends FilterEffect implements PoolItem\n{\n    constructor()\n    {\n        super();\n\n        this.filters = [new MaskFilter({\n            sprite: new Sprite(Texture.EMPTY),\n            inverse: false,\n            resolution: 'inherit',\n            antialias: 'inherit'\n        })];\n    }\n\n    get sprite(): Sprite\n    {\n        return (this.filters[0] as MaskFilter).sprite;\n    }\n\n    set sprite(value: Sprite)\n    {\n        (this.filters[0] as MaskFilter).sprite = value;\n    }\n\n    get inverse(): boolean\n    {\n        return (this.filters[0] as MaskFilter).inverse;\n    }\n\n    set inverse(value: boolean)\n    {\n        (this.filters[0] as MaskFilter).inverse = value;\n    }\n\n    public init: () => void;\n}\n\nexport interface AlphaMaskInstruction extends Instruction\n{\n    renderPipeId: 'alphaMask',\n    action: MaskMode,\n    mask: AlphaMask,\n    inverse: boolean;\n    maskedContainer: Container,\n    renderMask: boolean,\n}\n\nexport interface AlphaMaskData\n{\n    filterEffect: AlphaMaskEffect,\n    maskedContainer: Container,\n    previousRenderTarget?: RenderTarget,\n    filterTexture?: Texture,\n}\n\nexport class AlphaMaskPipe implements InstructionPipe<AlphaMaskInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'alphaMask',\n    } as const;\n\n    private _renderer: Renderer;\n    private _activeMaskStage: AlphaMaskData[] = [];\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(mask: Effect, maskedContainer: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'pushMaskBegin',\n            mask,\n            inverse: maskedContainer._maskOptions.inverse,\n            canBundle: false,\n            maskedContainer\n        } as AlphaMaskInstruction);\n\n        (mask as AlphaMask).inverse = maskedContainer._maskOptions.inverse;\n\n        if ((mask as AlphaMask).renderMaskToTexture)\n        {\n            const maskContainer = (mask as AlphaMask).mask;\n\n            maskContainer.includeInBuild = true;\n\n            collectAllRenderables(\n                maskContainer,\n                instructionSet,\n                renderer\n            );\n\n            maskContainer.includeInBuild = false;\n        }\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'pushMaskEnd',\n            mask,\n            maskedContainer,\n            inverse: maskedContainer._maskOptions.inverse,\n            canBundle: false,\n        } as AlphaMaskInstruction);\n    }\n\n    public pop(mask: Effect, _maskedContainer: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'popMaskEnd',\n            mask,\n            inverse: _maskedContainer._maskOptions.inverse,\n            canBundle: false,\n        } as AlphaMaskInstruction);\n    }\n\n    public execute(instruction: AlphaMaskInstruction)\n    {\n        const renderer = this._renderer;\n        const renderMask = instruction.mask.renderMaskToTexture;\n\n        if (instruction.action === 'pushMaskBegin')\n        {\n            const filterEffect = BigPool.get(AlphaMaskEffect);\n\n            filterEffect.inverse = instruction.inverse;\n\n            if (renderMask)\n            {\n                instruction.mask.mask.measurable = true;\n\n                const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds);\n\n                instruction.mask.mask.measurable = false;\n\n                bounds.ceil();\n\n                const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n                const filterTexture = TexturePool.getOptimalTexture(\n                    bounds.width,\n                    bounds.height,\n                    colorTextureSource._resolution,\n                    colorTextureSource.antialias\n                );\n\n                renderer.renderTarget.push(filterTexture, true);\n\n                renderer.globalUniforms.push({\n                    offset: bounds,\n                    worldColor: 0xFFFFFFFF\n                });\n\n                const sprite = filterEffect.sprite;\n\n                sprite.texture = filterTexture;\n\n                sprite.worldTransform.tx = bounds.minX;\n                sprite.worldTransform.ty = bounds.minY;\n\n                this._activeMaskStage.push({\n                    filterEffect,\n                    maskedContainer: instruction.maskedContainer,\n                    filterTexture,\n                });\n            }\n            else\n            {\n                filterEffect.sprite = instruction.mask.mask as Sprite;\n\n                this._activeMaskStage.push({\n                    filterEffect,\n                    maskedContainer: instruction.maskedContainer,\n                });\n            }\n        }\n        else if (instruction.action === 'pushMaskEnd')\n        {\n            const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];\n\n            if (renderMask)\n            {\n                // WebGPU blit's automatically, but WebGL does not!\n                if (renderer.type === RendererType.WEBGL)\n                {\n                    renderer.renderTarget.finishRenderPass();\n                }\n\n                renderer.renderTarget.pop();\n                renderer.globalUniforms.pop();\n            }\n\n            renderer.filter.push({\n                renderPipeId: 'filter',\n                action: 'pushFilter',\n                container: maskData.maskedContainer,\n                filterEffect: maskData.filterEffect,\n                canBundle: false,\n            });\n        }\n        else if (instruction.action === 'popMaskEnd')\n        {\n            renderer.filter.pop();\n\n            const maskData = this._activeMaskStage.pop();\n\n            if (renderMask)\n            {\n                TexturePool.returnTexture(maskData.filterTexture);\n            }\n\n            BigPool.return(maskData.filterEffect);\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n        this._activeMaskStage = null;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}